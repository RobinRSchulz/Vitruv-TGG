@article{becker2008a,
  author = {Steffen Becker and Heiko Koziolek and Ralf Reussner},
  title = {{The Palladio Component Model for Model-driven Performance Prediction}},
  journal = {Journal of Systems and Software},
  year = {2009},
  volume = {82},
  pages = {3--22},
  doi = {10.1016/j.jss.2008.03.066},
  publisher = {Elsevier Science Inc.},
  url = {http://dx.doi.org/10.1016/j.jss.2008.03.066}
}

@misc{noauthor_vitruv-toolsvitruv-casestudies_nodate,
	title = {vitruv-tools/{Vitruv}-{CaseStudies}: {Case} {Studies} for the {Vitruvius} {Framework}},
	url = {https://github.com/vitruv-tools/Vitruv-CaseStudies},
	urldate = {2025-05-10},
	file = {vitruv-tools/Vitruv-CaseStudies\: Case Studies for the Vitruvius Framework:C\:\\Users\\XPS-15\\Zotero\\storage\\8BZFJ2ZR\\Vitruv-CaseStudies.html:text/html},
}


@misc{noauthor_junit_nodate,
	title = {{JUnit} 5},
	url = {https://junit.org/junit5/},
	urldate = {2025-05-10},
	file = {JUnit 5:C\:\\Users\\XPS-15\\Zotero\\storage\\A7PPTMT5\\junit5.html:text/html},
}


@misc{chen_java-to-uml,
    author = {Fei Chen},
	title = {Änderungsgetriebene Konsistenzhaltung zwischen UML-Klassenmodellen und Java-Code. Bachelors’s thesis, Karlsruhe Institute of Technology (KIT),},
    publisher = {Karlsruhe Institute of Technology (KIT)},
    year = {2017},
}

@article{VitruviusKlare2021,
title = {Enabling consistency in view-based system development — The Vitruvius approach},
journal = {Journal of Systems and Software},
volume = {171},
pages = {110815},
year = {2021},
issn = {0164-1212},
doi = {https://doi.org/10.1016/j.jss.2020.110815},
url = {https://www.sciencedirect.com/science/article/pii/S0164121220302144},
author = {Heiko Klare and Max E. Kramer and Michael Langhammer and Dominik Werle and Erik Burger and Ralf Reussner},
keywords = {Consistency, Model-driven software development, Model transformations, Model views},
abstract = {During the development of large software-intensive systems, developers use several modeling languages and tools to describe a system from different viewpoints. Model-driven and view-based technologies have made it easier to define domain-specific languages and transformations. Nevertheless, using several languages leads to fragmentation of information, to redundancies in the system description, and eventually to inconsistencies. Inconsistencies have negative impacts on the system’s quality and are costly to fix. Often, there is no support for consistency management across multiple languages. Using a single language is no practicable solution either, as it is overly complex to define, use, and evolve such a language. View-based development is a suitable approach to deal with complex systems, and is widely used in other engineering disciplines. Still, we need to cope with the problems of fragmentation and consistency. In this paper, we present the Vitruvius approach for consistency in view-based modeling. We describe the approach by formalizing the notion of consistency, presenting languages for consistency preservation, and defining a model-driven development process. Furthermore, we show how existing models can be integrated. We have evaluated our approach at two case studies from component-based and embedded automotive software development, using our prototypical implementation based on the Eclipse Modeling Framework.}
}

@inproceedings{kent_model_2002,
	address = {Berlin, Heidelberg},
	title = {Model {Driven} {Engineering}},
	isbn = {978-3-540-47884-3},
	doi = {10.1007/3-540-47884-1_16},
	abstract = {The Object Management Group’s (OMG) Model Driven Architecture (MDA) strategy envisages a world where models play a more direct role in software production, being amenable to manipulation and transformation by machine. Model Driven Engineering (MDE) is wider in scope than MDA. MDE combines process and analysis with architecture. This article sets out a framework for model driven engineering, which can be used as a point of reference for activity in this area. It proposes an organisation of the modelling ‘space’ and how to locate models in that space. It discusses different kinds of mappings between models. It explains why process and architecture are tightly connected. It discusses the importance and nature of tools. It identifies the need for defining families of languages and transformations, and for developing techniques for generating/configuring tools from such definitions. It concludes with a call to align metamodelling with formal language engineering techniques.},
	language = {en},
	booktitle = {Integrated {Formal} {Methods}},
	publisher = {Springer},
	author = {Kent, Stuart},
	editor = {Butler, Michael and Petre, Luigia and Sere, Kaisa},
	year = {2002},
	pages = {286--298},
}


@inproceedings{hutchinson_model-driven_2011,
	address = {New York, NY, USA},
	series = {{ICSE} '11},
	title = {Model-driven engineering practices in industry},
	isbn = {978-1-4503-0445-0},
	url = {https://doi.org/10.1145/1985793.1985882},
	doi = {10.1145/1985793.1985882},
	abstract = {In this paper, we attempt to address the relative absence of empirical studies of model driven engineering through describing the practices of three commercial organizations as they adopted a model driven engineering approach to their software development. Using in-depth semi-structured interviewing we invited practitioners to reflect on their experiences and selected three to use as exemplars or case studies. In documenting some details of attempts to deploy model driven practices, we identify some 'lessons learned', in particular the importance of complex organizational, managerial and social factors - as opposed to simple technical factors - in the relative success, or failure, of the endeavour. As an example of organizational change management the successful deployment of model driven engineering appears to require: a progressive and iterative approach; transparent organizational commitment and motivation; integration with existing organizational processes and a clear business focus.},
	urldate = {2025-05-09},
	booktitle = {Proceedings of the 33rd {International} {Conference} on {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Hutchinson, John and Rouncefield, Mark and Whittle, Jon},
	month = may,
	year = {2011},
	pages = {633--642},
}

@article{hutchinson_model-driven_2014,
	series = {Special issue on {Success} {Stories} in {Model} {Driven} {Engineering}},
	title = {Model-driven engineering practices in industry: {Social}, organizational and managerial factors that lead to success or failure},
	volume = {89},
	issn = {0167-6423},
	shorttitle = {Model-driven engineering practices in industry},
	url = {https://www.sciencedirect.com/science/article/pii/S0167642313000786},
	doi = {10.1016/j.scico.2013.03.017},
	abstract = {In this article, we attempt to address the relative absence of empirical studies of model driven engineering (MDE) in two different but complementary ways. First, we present an analysis of a large online survey of MDE deployment and experience that provides some rough quantitative measures of MDE practices in industry. Second, we supplement these figures with qualitative data obtained from some semi-structured, in-depth interviews with MDE practitioners, and, in particular, through describing the practices of four commercial organizations as they adopted a model driven engineering approach to their software development practices. Using in-depth semi-structured interviewing, we invited practitioners to reflect on their experiences and selected four to use as exemplars or case studies. In documenting some details of their attempts to deploy model driven practices, we identify a number of factors, in particular the importance of complex organizational, managerial and social factors–as opposed to simple technical factors–that appear to influence the relative success, or failure, of the endeavor. Three of the case study companies describe genuine success in their use of model driven development, but explain that as examples of organizational change management, the successful deployment of model driven engineering appears to require: a progressive and iterative approach; transparent organizational commitment and motivation; integration with existing organizational processes and a clear business focus.},
	urldate = {2025-05-09},
	journal = {Science of Computer Programming},
	author = {Hutchinson, John and Whittle, Jon and Rouncefield, Mark},
	month = sep,
	year = {2014},
	keywords = {Empirical software engineering, Industry practice, Model driven engineering},
	pages = {144--161},
	file = {ScienceDirect Snapshot:C\:\\Users\\XPS-15\\Zotero\\storage\\DNJJQ3YY\\S0167642313000786.html:text/html},
}

@article{whittle_state_2014,
	title = {The {State} of {Practice} in {Model}-{Driven} {Engineering}},
	volume = {31},
	issn = {1937-4194},
	url = {https://ieeexplore.ieee.org/abstract/document/6507223},
	doi = {10.1109/MS.2013.65},
	abstract = {Despite lively debate over the past decade on the benefits and drawbacks of model-driven engineering (MDE), there have been few industry-wide studies of MDE in practice. A new study that surveyed 450 MDE practitioners and performed in-depth interviews with 22 more suggests that although MDE might be more widespread than commonly believed, developers rarely use it to generate whole systems. Rather, they apply MDE to develop key parts of a system.},
	number = {3},
	urldate = {2025-05-09},
	journal = {IEEE Software},
	author = {Whittle, Jon and Hutchinson, John and Rouncefield, Mark},
	month = may,
	year = {2014},
	keywords = {Companies, Computer architecture, DSL, Industries, Interviews, MDE, model driven engineering practice, Software, software design, software design methodologies, Unified modeling language},
	pages = {79--85},
	file = {Accepted Version:C\:\\Users\\XPS-15\\Zotero\\storage\\E3L6PB43\\Whittle et al. - 2014 - The State of Practice in Model-Driven Engineering.pdf:application/pdf},
}



@article{eMoflonIBeX_weidmann_incremental_nodate,
	title = {Incremental {Bidirectional} {Model} {Transformation} with {eMoﬂon}::{IBeX}},
	abstract = {Consistency management is a crucial task in the context of modeldriven engineering, as diﬀerent teams of domain experts must be able to work concurrently with their diﬀerent models. Triple Graph Grammars (TGGs) are a well-known approach to consistency management with the unique advantage of being declarative enough to address multiple consistency management operations with the same speciﬁcation, while still achieving an acceptable level of scalability for realistic application scenarios. Although there have been numerous TGG-based tools in the past, to the best of our knowledge, there exists no TGG-based tool that addresses multiple consistency management operations in a conceptually and technically uniform manner. We argue that this is the reason why TGG-based tools typically do not maintain the same level of support for more than one or two such operations. In this paper, therefore, we present eMoﬂon::IBeX, a novel TGG-based tool that is able to handle model generation, model synchronisation, and consistency checking by applying essentially the same approach.},
	language = {en},
    journal={Graph Transformation: 12th International Conference, ICGT 2019, Held as Part of STAF 2019, Eindhoven, The Netherlands, July 15--16, 2019, Proceedings 12},
    pages={131--140},
    year={2019},
	author = {Weidmann, Nils and Anjorin, Anthony and Varro, Gergely and Fritsche, Lars and Schurr, Andy and Leblebici, Erhan},
	file = {PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\DZEF2G48\\Weidmann et al. - Incremental Bidirectional Model Transformation with eMoﬂonIBeX.pdf:application/pdf},
}

@inproceedings{schurr_tggs_1995,
	address = {Berlin, Heidelberg},
	title = {Specification of graph translators with triple graph grammars},
	isbn = {978-3-540-49183-5},
	doi = {10.1007/3-540-59071-4_45},
	abstract = {Data integration is a key issue for any integrated set of software tools. A typical CASE environment, for instance, offers tools for the manipulation of requirements and software design documents, and it provides more or less sophisticated assistance for keeping these documents in a consistent state. Up to now, almost all data consistency observing or preserving integration tools are hand-crafted due to the lack of generic implementation frameworks and the absence of adequate specification formalisms. Triple graph grammars are intended to fill this gap and to support the specification of interdependencies between graph-like data structures on a very high level. Furthermore, they are the fundamentals of a new machinery for the production of batch-oriented as well as incrementally working data integration tools.},
	language = {en},
	booktitle = {Graph-{Theoretic} {Concepts} in {Computer} {Science}},
	publisher = {Springer},
	author = {Schürr, Andy},
	editor = {Mayr, Ernst W. and Schmidt, Gunther and Tinhofer, Gottfried},
	year = {1995},
	keywords = {Graph Grammar, Related Graph, Syntax Tree, Target Graph, Triple Production},
	pages = {151--163},
	file = {Full Text PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\3RJU736A\\Schürr - 1995 - Specification of graph translators with triple graph grammars.pdf:application/pdf},
}


@misc{model_driven_architecture_omg,
	title = {{OMG} {Document} -- ormsc/14-06-01 ({MDA} {Guide} revision 2.0)},
	url = {http://www.omg.org/cgi-bin/doc?ormsc/14-06-01},
	urldate = {2024-09-23},
	file = {OMG Document -- ormsc/14-06-01 (MDA Guide revision 2.0):C\:\\Users\\XPS-15\\Zotero\\storage\\VVJJH9RY\\doc.html:text/html;PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\Y7KY7JAQ\\OMG Document -- ormsc14-06-01 (MDA Guide revision 2.0).pdf:application/pdf},
}

@article{czarnecki_helsen_feature_based_survey_2006,
	title = {Feature-based survey of model transformation approaches},
	volume = {45},
	issn = {0018-8670},
	url = {http://ieeexplore.ieee.org/document/5386627/},
	doi = {10.1147/sj.453.0621},
	language = {en},
	number = {3},
	urldate = {2024-09-20},
	journal = {IBM Systems Journal},
	author = {Czarnecki, K. and Helsen, S.},
	year = {2006},
	pages = {621--645},
	file = {PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\NAPPAHJN\\Czarnecki and Helsen - 2006 - Feature-based survey of model transformation approaches.pdf:application/pdf},
}

@article{kahani_survey_classification_tools_2019,
	title = {Survey and classification of model transformation tools},
	volume = {18},
	issn = {1619-1374},
	url = {https://doi.org/10.1007/s10270-018-0665-6},
	doi = {10.1007/s10270-018-0665-6},
	abstract = {Model transformation lies at the very core of model-driven engineering, and a large number of model transformation languages and tools have been proposed over the last few years. These tools can be used to develop, transform, merge, exchange, compare, and verify models and metamodels. In this paper, we present a comprehensive catalog of existing metamodel-based transformation tools and compare them using a qualitative framework. We begin by organizing the 60 tools we identified into a general classification based on the transformation approach used. We then compare these tools using a number of particular facets, where each facet belongs to one of six different categories and may contain several attributes. The results of the study are discussed in detail and made publicly available in a companion website with a capability to search for tools using the specified facets as search criteria. Our study provides a thorough picture of the state-of-the-art in model transformation techniques and tools. Our results are potentially beneficial to many stakeholders in the modeling community, including practitioners, researchers, and transformation tool developers.},
	language = {en},
	number = {4},
	urldate = {2024-09-20},
	journal = {Software \& Systems Modeling},
	author = {Kahani, Nafiseh and Bagherzadeh, Mojtaba and Cordy, James R. and Dingel, Juergen and Varró, Daniel},
	month = aug,
	year = {2019},
	keywords = {Artificial Intelligence, Classification, Metamodel, Model transformation tools, Model-driven development, Survey},
	pages = {2361--2397},
	file = {Full Text PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\K6W2ZNS2\\Kahani et al. - 2019 - Survey and classification of model transformation tools.pdf:application/pdf},
}


@article{hoffmann_pattern_matching_bupm_1982,
	title = {Pattern {Matching} in {Trees}},
	volume = {29},
	issn = {0004-5411},
	url = {https://dl.acm.org/doi/10.1145/322290.322295},
	doi = {10.1145/322290.322295},
	number = {1},
	urldate = {2024-09-24},
	journal = {J. ACM},
	author = {Hoffmann, Christoph M. and O'Donnell, Michael J.},
	month = jan,
	year = {1982},
	pages = {68--95},
	file = {Full Text PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\ZXFERLQX\\Hoffmann and O'Donnell - 1982 - Pattern Matching in Trees.pdf:application/pdf},
}


@inproceedings{ebner_instruction_selection_ssa_pattern_matching_2008,
	address = {New York, NY, USA},
	series = {{LCTES} '08},
	title = {Generalized instruction selection using {SSA}-graphs},
	isbn = {978-1-60558-104-0},
	url = {https://dl.acm.org/doi/10.1145/1375657.1375663},
	doi = {10.1145/1375657.1375663},
	abstract = {Instruction selection is a well-studied compiler phase that translates the compiler's intermediate representation of programs to a sequence of target-dependent machine instructions optimizing for various compiler objectives (e.g. speed and space). Most existing instruction selection techniques are limited to the scope of a single statement or a basic block and cannot cope with irregular instruction sets that are frequently found in embedded systems.We consider an optimal technique for instruction selection that uses Static Single Assignment (SSA) graphs as an intermediate representation of programs and employs the Partitioned Boolean Quadratic Problem (PBQP) for finding an optimal instruction selection. While existing approaches are limited to instruction patterns that can be expressed in a simple tree structure, we consider complex patterns producing multiple results at the same time including pre/post increment addressing modes, div-mod instructions, and SIMD extensions frequently found in embedded systems. Although both instruction selection on SSA-graphs and PBQP are known to be NP-complete, the problem can be solved efficiently - even for very large instances.Our approach has been implemented in LLVM for an embedded ARMv5 architecture. Extensive experiments show speedups of up to 57\% on typical DSP kernels and up to 10\% on SPECINT 2000 and MiBench benchmarks. All of the test programs could be compiled within less than half a minute using a heuristic PBQP solver that solves 99.83\% of all instances optimally.},
	urldate = {2024-09-24},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN}-{SIGBED} conference on {Languages}, compilers, and tools for embedded systems},
	publisher = {Association for Computing Machinery},
	author = {Ebner, Dietmar and Brandner, Florian and Scholz, Bernhard and Krall, Andreas and Wiedermann, Peter and Kadlec, Albrecht},
	month = jun,
	year = {2008},
	pages = {31--40},
	file = {Full Text PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\A4TI7XNT\\Ebner et al. - 2008 - Generalized instruction selection using SSA-graphs.pdf:application/pdf},
}

@misc{OMG_UML_2.5.1,
	title = {https://www.omg.org/spec/{UML}/2.5.1/{PDF}},
	url = {https://www.omg.org/spec/UML/2.5.1/PDF},
	urldate = {2024-09-24},
	file = {https\://www.omg.org/spec/UML/2.5.1/PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\FTVEFYXZ\\PDF.pdf:application/pdf},
}

@inproceedings{caplat_model_mapping_MDA_2002,
	title = {Model mapping in {MDA}},
	volume = {196},
	booktitle = {Workshop in {Software} {Model} {Engineering} ({WISME2002})},
	publisher = {Citeseer},
	author = {Caplat, Guy and Sourrouille, Jean Louis},
	year = {2002},
	file = {Available Version (via Google Scholar):C\:\\Users\\XPS-15\\Zotero\\storage\\QESXXRKX\\Caplat and Sourrouille - 2002 - Model mapping in MDA.pdf:application/pdf},
}

@techreport{harel_modeling_languages_syntax_semantics_2000,
	title = {Modeling languages: {Syntax}, semantics and all that stuff},
	shorttitle = {Modeling languages},
	url = {https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=072663058126978f4b6478121c71de30e404160c},
	urldate = {2024-09-24},
	institution = {Citeseer},
	author = {Harel, David and Rumpe, Bernhard},
	year = {2000},
	file = {Available Version (via Google Scholar):C\:\\Users\\XPS-15\\Zotero\\storage\\NHM84633\\Harel and Rumpe - 2000 - Modeling languages Syntax, semantics and all that stuff.pdf:application/pdf},
}


@inproceedings{fritsche_short-cut-theoretical_2018,
	address = {Cham},
	title = {Short-{Cut} {Rules}},
	isbn = {978-3-030-04771-9},
	doi = {10.1007/978-3-030-04771-9_30},
	abstract = {Sequences of rule applications in high-level replacement systems are difficult to adapt. Often, replacing a rule application at the beginning of a sequence, i.e., reverting a rule and applying another one instead, is prevented by structure created via rule applications later on in the sequence. A trivial solution would be to roll back all applications and reapply them in a proper way. This, however, has the disadvantage of being computationally expensive and, furthermore, may cause the loss of information in the process. Moreover, using existing constructions to compose the reversal of a rule with the application of another one, in particular the concurrent and amalgamated rule constructions, does not prevent the loss of information in case that the first rule deletes elements being recreated by the second one. To cope with both problems, we introduce a new kind of rule composition through ‘short-cut rules’. We present our new kind of rule composition for monotonic rules in adhesive HLR systems, as they provide a well-established generalization of graph-based transformation systems, and motivate it on the example of Triple Graph Grammars, a declarative and rule-based bidirectional transformation approach.},
	language = {en},
	booktitle = {Software {Technologies}: {Applications} and {Foundations}},
	publisher = {Springer International Publishing},
	author = {Fritsche, Lars and Kosiol, Jens and Schürr, Andy and Taentzer, Gabriele},
	editor = {Mazzara, Manuel and Ober, Iulian and Salaün, Gwen},
	year = {2018},
	keywords = {Amalgamated rule, E-concurrent rule, Rule composition, Triple graph grammars, short-cut rules},
	pages = {415--430},
	file = {Full Text PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\2AAW53S8\\Fritsche et al. - 2018 - Short-Cut Rules.pdf:application/pdf},
}

@article{fritsche_short-cut-rules-repair-tgg_2021,
	title = {Avoiding unnecessary information loss: correct and efficient model synchronization based on triple graph grammars},
	volume = {23},
	issn = {1433-2787},
	shorttitle = {Avoiding unnecessary information loss},
	url = {https://doi.org/10.1007/s10009-020-00588-7},
	doi = {10.1007/s10009-020-00588-7},
	abstract = {Model synchronization, i.e., the task of restoring consistency between two interrelated models after a model change, is a challenging task. Triple graph grammars (TGGs) specify model consistency by means of rules that describe how to create consistent pairs of models. These rules can be used to automatically derive further rules, which describe how to propagate changes from one model to the other or how to change one model in such a way that propagation is guaranteed to be possible. Restricting model synchronization to these derived rules, however, may lead to unnecessary deletion and recreation of model elements during change propagation. This is inefficient and may cause unnecessary information loss, i.e., when deleted elements contain information that is not represented in the second model, this information cannot be recovered easily. Short-cut rules have recently been developed to avoid unnecessary information loss by reusing existing model elements. In this paper, we show how to automatically derive (short-cut) repair rules from short-cut rules to propagate changes such that information loss is avoided and model synchronization is accelerated. The key ingredients of our rule-based model synchronization process are these repair rules and an incremental pattern matcher informing about suitable applications of them. We prove the termination and the correctness of this synchronization process and discuss its completeness. As a proof of concept, we have implemented this synchronization process in eMoflon, a state-of-the-art model transformation tool with inherent support of bidirectionality. Our evaluation shows that repair processes based on (short-cut) repair rules have considerably decreased information loss and improved performance compared to former model synchronization processes based on TGGs.},
	language = {en},
	number = {3},
	urldate = {2024-09-14},
	journal = {International Journal on Software Tools for Technology Transfer},
	author = {Fritsche, Lars and Kosiol, Jens and Schürr, Andy and Taentzer, Gabriele},
	month = jun,
	year = {2021},
	keywords = {Bidirectional transformation, Change propagation, Incremental pattern matching, Model synchronization, Triple graph grammar, short-cut rules},
	pages = {335--368},
	file = {Full Text PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\WUYUYSYF\\Fritsche et al. - 2021 - Avoiding unnecessary information loss correct and efficient model synchronization based on triple g.pdf:application/pdf},
}

@misc{noauthor_emf_eobject_nodate,
	title = {{EObject} ({EMF} {Documentation})},
	url = {https://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/EObject.html},
	urldate = {2025-05-10},
	file = {EObject (EMF Documentation):C\:\\Users\\XPS-15\\Zotero\\storage\\NUU74QE4\\EObject.html:text/html},
}

@misc{noauthor_jdk_21nodate,
	title = {{JDK} 21 {Documentation} - {Home}},
	url = {https://docs.oracle.com/en/java/javase/21/},
	abstract = {The documentation for JDK 21 includes developer guides, API documentation, and release notes.},
	language = {en},
	urldate = {2025-05-10},
	journal = {Oracle Help Center},
	file = {Snapshot:C\:\\Users\\XPS-15\\Zotero\\storage\\HWJXV3BT\\21.html:text/html},
}

@misc{hipe-devops_highly_2022,
	title = {Highly ({Scalable}) {Incremental} {Pattern} matching {Engine} ({HiPE})},
	copyright = {GPL-3.0},
	url = {https://github.com/HiPE-DevOps/HiPE-Updatesite},
	urldate = {2025-05-01},
	author = {{HiPE-DevOps}},
	month = may,
	year = {2022},
	note = {original-date: 2019-07-31T13:27:23Z},
}

@article{weidmann_emoflonneo_nodate,
	title = {{eMoflon}::{Neo} - {Consistency} and {Model} {Management} with {Graph} {Databases}},
	abstract = {Maintaining the consistency of interrelated models is an important task in the context of Model-Driven Engineering (MDE). Appropriate tool support is crucial to achieve an adequate level of automation required for successful model management in general, and consistency maintenance in particular. Numerous MDE tools, including the tools in the eMoflon toolsuite, build upon the Eclipse Modeling Framework (EMF), a de-facto MDE standard. While EMF is a great framework, it has some drawbacks regarding scalability and flexibility with respect to metamodel conformance.},
	language = {en},
    journal={STAF workshops},
    pages={54--64},
    year={2021},
	author = {Weidmann, Nils and Anjorin, Anthony},
	file = {PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\8AW2ZDBB\\Weidmann and Anjorin - eMoflonNeo - Consistency and Model Management with Graph Databases.pdf:application/pdf},
}

@misc{noauthor_emf_compare,
	title = {{EMF} {Compare} {\textbar} {Home}},
	url = {https://eclipse.dev/emf/compare/},
	urldate = {2025-05-09},
	file = {EMF Compare | Home:C\:\\Users\\XPS-15\\Zotero\\storage\\SIF5TNDV\\compare.html:text/html},
}

@misc{noauthor_github_emoflon_tutorial,
	title = {{eMoflon}/emoflon-ibex-tutorial: {Tutorial} projects and documentation for {eMoflon}::{IBeX}.},
	url = {https://github.com/eMoflon/emoflon-ibex-tutorial/tree/master},
	urldate = {2025-05-09},
	file = {GitHub - eMoflon/emoflon-ibex-tutorial\: Tutorial projects and documentation for eMoflon\:\:IBeX.:C\:\\Users\\XPS-15\\Zotero\\storage\\3MFN9PNV\\master.html:text/html},
}

@article{kratz_model-driven_2025,
	title = {Model-{Driven} {Rapid} {Prototyping} for {Control} {Algorithms} with the {GIPS} {Framework} ({System} {Description})},
	volume = {417},
	issn = {2075-2180},
	url = {https://eptcs.web.cse.unsw.edu.au/paper.cgi?GCM2023.9},
	doi = {10.4204/EPTCS.417.9},
	language = {en},
	urldate = {2025-05-12},
	journal = {Electronic Proceedings in Theoretical Computer Science},
	author = {Kratz, Maximilian and Ehmes, Sebastian and Menzel, Philipp Maximilian and Schürr, Andy},
	month = mar,
	year = {2025},
	pages = {157--172},
	file = {PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\GLPYDYXW\\Kratz et al. - 2025 - Model-Driven Rapid Prototyping for Control Algorithms with the GIPS Framework (System Description).pdf:application/pdf},
}

@article{forgy_rete_1982,
	title = {Rete: {A} fast algorithm for the many pattern/many object pattern match problem},
	volume = {19},
	issn = {0004-3702},
	shorttitle = {Rete},
	url = {https://www.sciencedirect.com/science/article/pii/0004370282900200},
	doi = {10.1016/0004-3702(82)90020-0},
	abstract = {The Rete Match Algorithm is an efficient method for comparing a large collection of patterns to a large collection of objects. It finds all the objects that match each pattern. The algorithm was developed for use in production system interpreters, and it has been used for systems containing from a few hundred to more than a thousand patterns and objects. This article presents the algorithm in detail. It explains the basic concepts of the algorithm, it describes pattern and object representations that are appropriate for the algorithm, and it describes the operations performed by the pattern matcher.},
	number = {1},
	urldate = {2025-05-12},
	journal = {Artificial Intelligence},
	author = {Forgy, Charles L.},
	month = sep,
	year = {1982},
	pages = {17--37},
	file = {ScienceDirect Snapshot:C\:\\Users\\XPS-15\\Zotero\\storage\\7W7E5PYN\\0004370282900200.html:text/html},
}


@inproceedings{fritsche_higher_order_short_cut_rules_2023,
	address = {Cham},
	title = {Advanced {Consistency} {Restoration} with {Higher}-{Order} {Short}-{Cut} {Rules}},
	isbn = {978-3-031-36709-0},
	doi = {10.1007/978-3-031-36709-0_10},
	abstract = {Sequential model synchronisation is the task of propagating changes from one model to another correlated one to restore consistency. It is challenging to perform this propagation in a least-changing way that avoids unnecessary deletions (which might cause information loss). From a theoretical point of view, so-called short-cut (SC) rules have been developed that enable provably correct propagation of changes while avoiding information loss. However, to be able to react to every possible change, an infinite set of such rules might be necessary. Practically, only small sets of pre-computed basic SC rules have been used, severely restricting the kind of changes that can be propagated without loss of information. In this work, we close that gap by developing an approach to compute more complex required SC rules on-the-fly during synchronisation. These higher-order SC rules allow us to cope with more complex scenarios when multiple changes must be handled in one step. We implemented our approach in the model transformation tool eMoflon. An evaluation shows that the overhead of computing higher-order SC rules on-the-fly is tolerable and at times even improves the overall performance. Above that, completely new scenarios can be dealt with without the loss of information.},
	language = {en},
	booktitle = {Graph {Transformation}},
	publisher = {Springer Nature Switzerland},
	author = {Fritsche, Lars and Kosiol, Jens and Möller, Adrian and Schürr, Andy},
	editor = {Fernández, Maribel and Poskitt, Christopher M.},
	year = {2023},
	keywords = {Consistency restoration, Least-change synchronisation, Model synchronisation, Triple-graph grammars, short-cut rules},
	pages = {184--203},
	file = {Full Text PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\CNN9G34W\\Fritsche et al. - 2023 - Advanced Consistency Restoration with Higher-Order Short-Cut Rules.pdf:application/pdf},
}
@misc{iso_42010,
	title = {International Organization for Standardization, 2011. Systems and Software Engineering – Architecture Description (ISO/IEC/IEEE 42010:2011(E))},
	shorttitle = {{ISO}/{IEC}/{IEEE} 42010},
	abstract = {Systems and software engineering — Architecture description},
	language = {en},
	journal = {ISO},
	file = {Snapshot:C\:\\Users\\XPS-15\\Zotero\\storage\\MLYGBNRY\\50508.html:text/html},
}


@inproceedings{klare_commonalities_2019,
	title = {Commonalities for {Preserving} {Consistency} of {Multiple} {Models}},
	url = {https://ieeexplore.ieee.org/document/8904619/?arnumber=8904619},
	doi = {10.1109/MODELS-C.2019.00058},
	abstract = {Models are used to describe different properties of a software system. Those models often share information that is represented redundantly and, thus, has to be kept consistent. Defining model transformations between the involved metamodels is a common means to preserve the consistency of their instances. Such transformations specify the relations between instances of metamodels and how to enforce them. However, redundancies are often caused by different models containing representations of the same concept. We propose to make such common, duplicated concepts explicit instead of encoding them in transformations implicitly. We achieve this by defining an additional concept metamodel and the relations between it and the existing metamodels, which we call the Commonalities approach. We describe a language that allows to define both a concept metamodel and its relations to existing metamodels in one place, in order to achieve conciseness comparable to a direct transformation between the metamodels. Additionally, our approach allows hierarchical composition of concept metamodels to keep multiple models consistent. The expected benefits of our approach are an improved understandability of relations between metamodels by making the information about commonalities explicit, reduced errors in comparison to the combination of several transformations to keep multiple models consistent, and improved reusability because metamodels are not related directly, but only through concept metamodels.},
	urldate = {2024-09-17},
	booktitle = {2019 {ACM}/{IEEE} 22nd {International} {Conference} on {Model} {Driven} {Engineering} {Languages} and {Systems} {Companion} ({MODELS}-{C})},
	author = {Klare, Heiko and Gleitze, Joshua},
	month = sep,
	year = {2019},
	keywords = {model consistency, model transformation, multidirectional transformation, commonalities},
	pages = {371--378},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\XPS-15\\Zotero\\storage\\WPUFBYSS\\8904619.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\C77RKVGR\\Klare and Gleitze - 2019 - Commonalities for Preserving Consistency of Multiple Models.pdf:application/pdf},
}

@book{steinberg_emf_2008,
	title = {{EMF}: eclipse modeling framework},
	shorttitle = {{EMF}},
	url = {https://books.google.de/books?hl=en&lr=&id=sA0zOZuDXhgC&oi=fnd&pg=PT20&dq=EMF:+Eclipse+Modeling+Framework+Steinberg&ots=2LJKXVXkIp&sig=uUG9wKW8bSbFFP47IpWYJ1mUwmQ},
	urldate = {2024-09-27},
	publisher = {Pearson Education},
	author = {Steinberg, Dave and Budinsky, Frank and Merks, Ed and Paternostro, Marcelo},
	year = {2008},
	file = {Available Version (via Google Scholar):C\:\\Users\\XPS-15\\Zotero\\storage\\ZHXTXFT2\\Steinberg et al. - 2008 - EMF eclipse modeling framework.pdf:application/pdf},
}

@misc{kramer_specification_2017,
	title = {Specification {Languages} for {Preserving} {Consistency} between {Models} of {Different} {Languages}},
	url = {https://publikationen.bibliothek.kit.edu/1000069284},
	abstract = {In dieser Dissertation stellen wir drei Sprachen für die Entwicklung von Werkzeugen vor, welche Systemrepräsentationen während der Softwareentwicklung konsistent halten. Bei der Entwicklung komplexer informationstechnischer Systeme ist es üblich, mehrere Programmiersprachen und Modellierungssprachen zu nutzen. Dabei werden Teile des Systems mit unterschiedlichen Sprachen konstruiert und dargestellt, um verschiedene Entwurfs- und Entwicklungstätigkeiten zu unterstützen. Die übergreifende Struktur eines Systems wird beispielsweise oft mit Hilfe einer Architekturbeschreibungssprache dargestellt. Für die Spezifikation des detaillierten Verhaltens einzelner Systemteile ist hingegen eine zustandsbasierte Modellierungssprache oder eine Allzweckprogrammiersprache geeigneter. Da die Systemteile und Entwicklungstätigkeiten in Beziehung zueinander stehen, enthalten diese Repräsentationen oftmals auch redundante Informationen. Solche partiell redundanten Repräsentationen werden meist nicht statisch genutzt, sondern evolvieren während der Systementwicklung, was zu Inkonsistenzen und damit zu fehlerhaften Entwürfen und Implementierungen führen kann. Daher sind konsistente Systemrepräsentationen entscheidend für die Entwicklung solcher Systeme. Es gibt verschiedene Ansätze, die konsistente Systemrepräsentationen dadurch erreichen, dass Inkonsistenzen vermieden werden. So ist es beispielsweise möglich, eine zentrale, redundanzfreie Repräsentation zu erstellen, welche alle Informationen enthält, um alle anderen Repräsentationen daraus projizieren zu können. Es ist jedoch nicht immer praktikabel solch eine redundanzfreie Repräsentation und editierbare Projektionen zu erstellen, insbesondere wenn existierende Sprachen und Editoren unterstützt werden müssen. Eine weitere Möglichkeit zur Umgehung von Inkonsistenzen besteht darin Änderungen einzelner Informationen nur an einer eindeutigen Quellrepräsentation zuzulassen, sodass alle anderen Repräsentationen diese Information nur lesen können. Dadurch können solche Informationen in allen lesend zugreifenden Repräsentationen immer überschrieben werden, jedoch müssen dazu alle editierbaren Repräsentationsbereiche komplett voneinander getrennt werden. Falls inkonsistente Repräsentationen während der Systementwicklung nicht völlig vermieden werden können, müssen Entwickler oder Werkzeuge aktiv die Konsistenz erhalten, wenn Repräsentationen modifiziert werden. Die manuelle Konsistenthaltung ist jedoch eine zeitaufwändige und fehleranfällige Tätigkeit. Daher werden in Forschungseinrichtungen und in der Industrie Konsistenthaltungswerkzeuge entwickelt, die teilautomatisiert Modelle während der Systementwicklung aktualisieren. Solche speziellen Software-Entwicklungswerkzeuge können mit Allzweckprogrammiersprachen und mit dedizierten Konsistenthaltungssprachen entwickelt werden. In dieser Dissertation haben wir vier bedeutende Herausforderungen identifiziert, die momentan nur unzureichend von Sprachen zur Entwicklung von Konsistenthaltungswerkzeugen adressiert werden. Erstens kombinieren diese Sprachen spezifische Unterstützung zur Konsistenthaltung nicht mit der Ausdrucksmächtigkeit und Flexibilität etablierter Allzweckprogrammiersprachen. Daher sind Entwickler entweder auf ausgewiesene Anwendungsfälle beschränkt, oder sie müssen wiederholt Lösungen für generische Konsistenthaltungsprobleme entwickeln. Zweitens unterstützen diese Sprachen entweder lösungs- oder problemorientierte Programmierparadigmen, sodass Entwickler gezwungen sind, Erhaltungsinstruktionen auch in Fällen anzugeben, in denen Konsistenzdeklarationen ausreichend wären. Drittens abstrahieren diese Sprachen nicht von genügend Konsistenthaltungsdetails, wodurch Entwickler explizit beispielsweise Erhaltungsrichtungen, Änderungstypen oder Übereinstimmungsprobleme berücksichtigen müssen. Viertens führen diese Sprachen zu Erhaltungsverhalten, das oft vom konkreten Anwendungsfall losgelöst zu sein scheint, wenn Interpreter und Übersetzer Code ausführen oder erzeugen, der zur Realisierung einer spezifischen Konsistenzspezifikation nicht benötigt wird. Um diese Probleme aktueller Ansätze zu adressieren, leistet diese Dissertation die folgenden Beiträge: Erstens stellen wir eine Sammlung und Klassifizierung von Herausforderungen der Konsistenthaltung vor. Dabei diskutieren wir beispielsweise, welche Herausforderungen nicht bereits adressiert werden sollten, wenn Konsistenz spezifiziert wird, sondern erst wenn sie durchgesetzt wird. Zweitens führen wir einen Ansatz zur Erhaltung von Konsistenz gemäß abstrakter Spezifikationen ein und formalisieren ihn mengentheoretisch. Diese Formalisierung ist unabhängig davon wie Konsistenzdurchsetzungen letztendlich realisiert werden. Mit dem vorgestellten Ansatz wird Konsistenz immer anhand von beobachteten Editieroperationen bewahrt, um bekannte Probleme zur Berechnung von Übereinstimmungen und Differenzen zu vermeiden. Schließlich stellen wir drei neue Sprachen zur Entwicklung von Werkzeugen vor, die den vorgestellten, spezifikationsgeleiteten Ansatz verfolgen und welche wir im Folgenden kurz erläutern. Wir präsentieren eine imperative Sprache, die verwendet werden kann, um präzise zu spezifizieren, wie Modelle in Reaktion auf spezifische Änderungen aktualisiert werden müssen, um Konsistenz in eine Richtung zu erhalten. Diese Reaktionssprache stellt Lösungen für häufige Probleme bereit, wie beispielsweise die Identifizierung und das Abrufen geänderter oder korrespondierender Modellelemente. Außerdem erreicht sie eine uneingeschränkte Ausdrucksmächtigkeit, indem sie Entwicklern ermöglicht, auf eine Allzweckprogrammiersprache zurückzugreifen. Eine zweite, bidirektionale Sprache für abstrakte Abbildungen kann für Fälle verwendet werden, in denen verschiedene Änderungsoperationen nicht unterschieden werden müssen und außerdem die Erhaltungsrichtung nicht immer eine Rolle spielt. Mit dieser Abbildungssprache können Entwickler Bedingungen deklarieren, die ausdrücken, wann Modellelemente als konsistent zueinander angesehen werden sollen, ohne sich um Details der Überprüfung oder Durchsetzung von Konsistenz bemühen zu müssen. Dazu leitet der Übersetzer automatisch Durchsetzungscode aus Überprüfungen ab und bidirektionalisiert Bedingungen, die für eine Richtung der Konsistenthaltung spezifiziert wurden. Diese Bidirektionalisierung basiert auf einer erweiterbaren Menge von komponierbaren, operatorspezifischen Invertierern, die verbreitete Round-trip-Anforderungen erfüllen. Infolgedessen können Entwickler häufig vorkommende Konsistenzanforderungen konzise ausdrücken und müssen keinen Quelltext für verschiedene Konsistenthaltungsrichtungen, Änderungstypen oder Eigenschaften von Modellelementen wiederholen. Eine dritte, normative Sprache kann verwendet werden, um die vorherigen Sprachen mit parametrisierbaren Konsistenzinvarianten zu ergänzen. Diese Invariantensprache übernimmt Operatoren und Iteratoren für Elementsammlungen von der Object Constraint Language (OCL). Außerdem nimmt sie Entwicklern das Schreiben von Quelltext zur Suche nach invariantenverletzenden Elementen ab, da Abfragen, welche diese Aufgaben übernehmen, automatisch anhand von Invariantenparametern abgeleitet werden. Die drei Sprachen können in Kombination und einzeln verwendet werden. Sie ermöglichen es Entwicklern, Konsistenz unter Verwendung verschiedener Programmierparadigmen und Sprachabstraktionen zu spezifizieren. Wir stellen auch prototypische Übersetzer und Editoren für die drei Konsistenzspezifikationssprachen vor, welche auf dem Vitruvius-Rahmenwerk für Multi-Sichten-Modellierung basieren. Mit diesem Rahmenwerk werden Änderungen in textuellen und graphischen Editoren automatisch beobachtet, um Reaktionen auszulösen, Abbildungen durchzusetzen und Invarianten zu überprüfen. Dies geschieht indem der von unseren Übersetzern erzeugte Java-Code ausgeführt wird. Außerdem haben wir für alle Sprachen, die in dieser Dissertation vorgestellt werden, folgende theoretischen und praktischen Eigenschaften evaluiert: Vollständigkeit, Korrektheit, Anwendbarkeit, und Nutzen. So zeigen wir, dass die Sprachen ihre vorgesehenen Einsatzbereiche vollständig abdecken und analysieren ihre Berechnungsvollständigkeit. Außerdem diskutieren wir die Korrektheit jeder einzelnen Sprache sowie die Korrektheit einzelner Sprachmerkmale. Die operatorspezifischen Invertierer, die wir zur Bidirektionalisierung von Abbildungsbedingungen entwickelt haben, erfüllen beispielsweise immer das neu eingeführte Konzept bestmöglich erzogener Round-trips. Dieses basiert auf dem bewährten Konzept wohlerzogener Transformationen und garantiert, dass übliche Round-trip-Gesetze erfüllt werden, wann immer dies möglich ist. Wir veranschaulichen die praktische Anwendbarkeit mit Fallstudien, in denen Konsistenz erfolgreich mit Hilfe von Werkzeugen erhalten wurde, die in den von uns vorgestellten Sprachen geschrieben wurden. Zum Schluss diskutieren wir den potenziellen Nutzen unserer Sprachen und vergleichen beispielsweise Konsistenthaltungswerkzeuge die in zwei Fallstudien realisiert wurden. Die Werkzeuge, die mit der Reaktionssprache entwickelt wurden, benötigen zwischen 33\% und 71\% weniger Zeilen Quelltext als funktional gleichwertige Werkzeuge, die mit in Java oder dem Java-Dialekt Xtend entwickelt wurden.},
	language = {de},
	urldate = {2024-09-14},
	author = {Kramer, Max Emanuel},
	year = {2017},
	doi = {10.5445/IR/1000069284},
	file = {Full Text PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\6ZN7SHMX\\Kramer - 2017 - Specification Languages for Preserving Consistency between Models of Different Languages.pdf:application/pdf},
}

@techreport{kindler_wagner_triple_graph_grammars_TGG,
	title = {Triple {Graph} {Grammars}: {Concepts}, {Extensions}, {Implementations}, and {Application} {Scenarios}},
	abstract = {Triple Graph Grammars (TGGs) are a technique for deﬁning the correspondence between two diﬀerent types of models in a declarative way. The power of TGGs comes from the fact that the relation between the two models cannot only be deﬁned, but the deﬁnition can be made operational so that one model can be transformed into the other in either direction; even more, TGGs can be used to synchronize and to maintain the correspondence of the two models, even if both of them are changed independently of each other; i. e., TGGs work incrementally.},
	language = {en},
	author = {Kindler, Ekkart and Wagner, Robert},
	file = {PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\SSVP4E3B\\Kindler und Wagner - Triple Graph Grammars Concepts, Extensions, Implementations, and Application Scenarios.pdf:application/pdf},
}


@inproceedings{khelladi_detecting_complex_changes_2015,
	address = {Cham},
	title = {Detecting {Complex} {Changes} {During} {Metamodel} {Evolution}},
	isbn = {978-3-319-19069-3},
	doi = {10.1007/978-3-319-19069-3_17},
	abstract = {Evolution of metamodels can be represented at the finest grain by the trace of atomic changes: add, delete, and update elements. For many applications, like automatic correction of models when the metamodel evolves, a higher grained trace must be inferred, composed of complex changes, each one aggregating several atomic changes. Complex change detection is a challenging task since multiple sequences of atomic changes may define a single user intention and complex changes may overlap over the atomic change trace. In this paper, we propose a detection engine of complex changes that simultaneously addresses these two challenges of variability and overlap. We introduce three ranking heuristics to help users to decide which overlapping complex changes are likely to be correct. We describe an evaluation of our approach that allow reaching full recall. The precision is improved by our heuristics from 63\% and 71\% up to 91\% and 100\% in some cases.},
	language = {en},
	booktitle = {Advanced {Information} {Systems} {Engineering}},
	publisher = {Springer International Publishing},
	author = {Khelladi, Djamel Eddine and Hebig, Regina and Bendraou, Reda and Robin, Jacques and Gervais, Marie-Pierre},
	editor = {Zdravkovic, Jelena and Kirikova, Marite and Johannesson, Paul},
	year = {2015},
	keywords = {Complex change, Detection, Evolution, Metamodel},
	pages = {263--278},
	file = {Full Text PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\5DZ89XMJ\\Khelladi et al. - 2015 - Detecting Complex Changes During Metamodel Evolution.pdf:application/pdf},
}

@misc{vitruvius_correspondence_model_github_ecore,
	title = {Vitruv-{Change}/bundles/tools.vitruv.change.correspondence/metamodel/correspondence.ecore at main · vitruv-tools/{Vitruv}-{Change}},
	url = {https://github.com/vitruv-tools/Vitruv-Change/blob/main/bundles/tools.vitruv.change.correspondence/metamodel/correspondence.ecore},
	abstract = {Core Artifacts for Change Representation and Propagation - vitruv-tools/Vitruv-Change},
	language = {en},
	urldate = {2024-10-09},
	journal = {GitHub},
	file = {Snapshot:C\:\\Users\\XPS-15\\Zotero\\storage\\43PU5VM9\\correspondence.html:text/html},
}


@misc{emoflon_tutorial,
	title = {{eMoflon} ({TGG} tool) {Tutorial}},
	url = {https://github.com/eMoflon/emoflon-ibex-tutorial/releases/download/v2023.06.26/emoflon-tutorial.pdf},
	file = {PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\MYSCATRF\\_.pdf:application/pdf},
}


@inproceedings{atkinson_orthographic_2010_SUM_paper,
	address = {Berlin, Heidelberg},
	title = {Orthographic {Software} {Modeling}: {A} {Practical} {Approach} to {View}-{Based} {Development}},
	isbn = {978-3-642-14819-4},
	shorttitle = {Orthographic {Software} {Modeling}},
	doi = {10.1007/978-3-642-14819-4_15},
	abstract = {Although they are significantly different in how they decompose and conceptualize software systems, one thing that all advanced software engineering paradigms have in common is that they increase the number of different views involved in visualizing a system. Managing these different views can be challenging even when a paradigm is used independently, but when they are used together the number of views and inter-dependencies quickly becomes overwhelming. In this paper we present a novel approach for organizing and generating the different views used in advanced software engineering methods that we call Orthographic Software Modeling (OSM). This provides a simple metaphor for integrating different development paradigms and for leveraging domain specific languages in software engineering. Development environments that support OSM essentially raise the level of abstraction at which developers interact with their tools by hiding the idiosyncrasies of specific editors, storage choices and artifact organization policies. The overall benefit is to significantly simplify the use of advanced software engineering methods.},
	language = {en},
	booktitle = {Evaluation of {Novel} {Approaches} to {Software} {Engineering}},
	publisher = {Springer},
	author = {Atkinson, Colin and Stoll, Dietmar and Bostan, Philipp},
	editor = {Maciaszek, Leszek A. and González-Pérez, César and Jablonski, Stefan},
	year = {2010},
	keywords = {Atlas Transformation Language, Mobile Tourist, Platform Independent Model, Product Line Engineering, Storage Choice},
	pages = {206--219},
	file = {Full Text PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\FHAHA5EK\\Atkinson et al. - 2010 - Orthographic Software Modeling A Practical Approach to View-Based Development.pdf:application/pdf},
}

@book{stachowiak_allgemeine_modelltheorie_1973,
	title = {Allgemeine {Modelltheorie}},
	isbn = {978-3-211-81106-1},
	language = {de},
	publisher = {Springer},
	author = {Stachowiak, Herbert},
	year = {1973},
}

@article{ehrig_introduction_to_graph_grammers_1992,
	title = {Introduction to graph grammars with applications to semantic networks},
	volume = {23},
	copyright = {https://www.elsevier.com/tdm/userlicense/1.0/},
	issn = {08981221},
	url = {https://linkinghub.elsevier.com/retrieve/pii/089812219290124Z},
	doi = {10.1016/0898-1221(92)90124-Z},
	language = {en},
	number = {6-9},
	urldate = {2024-10-30},
	journal = {Computers \& Mathematics with Applications},
	author = {Ehrig, Hartmut and Habel, Annegret and Kreowski, Hans-Jörg},
	month = mar,
	year = {1992},
	pages = {557--572},
	file = {PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\8R3LN8W6\\Ehrig et al. - 1992 - Introduction to graph grammars with applications to semantic networks.pdf:application/pdf},
}


@article{basili_methodology_gqm_1984,
	title = {A {Methodology} for {Collecting} {Valid} {Software} {Engineering} {Data}},
	volume = {SE-10},
	issn = {1939-3520},
	url = {https://ieeexplore.ieee.org/document/5010301?arnumber=5010301},
	doi = {10.1109/TSE.1984.5010301},
	abstract = {An effective data collection method for evaluating software development methodologies and for studying the software development process is described. The method uses goal-directed data collection to evaluate methodologies with respect to the claims made for them. Such claims are used as a basis for defining the goals of the data collection, establishing a list of questions of interest to be answered by data analysis, defining a set of data categorization schemes, and designing a data collection form. The data to be collected are based on the changes made to the software during development, and are obtained when the changes are made. To ensure accuracy of the data, validation is performed concurrently with software development and data collection. Validation is based on interviews with those people supplying the data. Results from using the methodology show that data validation is a necessary part of change data collection. Without it, as much as 50 percent of the data may be erroneous. Feasibility of the data collection methodology was demonstrated by applying it to five different projects in two different environments. The application showed that the methodology was both feasible and useful.},
	number = {6},
	urldate = {2024-11-03},
	journal = {IEEE Transactions on Software Engineering},
	author = {Basili, Victor R. and Weiss, David M.},
	month = nov,
	year = {1984},
	note = {Conference Name: IEEE Transactions on Software Engineering},
	keywords = {Application software, Control systems, Data collection, data collection methodology, Data engineering, error analysis, error classification, Error correction, Error correction codes, Laboratories, Programming, Software engineering, software engineering experimentation, Software maintenance, Software testing},
	pages = {728--738},
	file = {Full Text PDF:C\:\\Users\\XPS-15\\Zotero\\storage\\P9SP3SMS\\Basili and Weiss - 1984 - A Methodology for Collecting Valid Software Engineering Data.pdf:application/pdf;IEEE Xplore Abstract Record:C\:\\Users\\XPS-15\\Zotero\\storage\\ACBRUVIY\\5010301.html:text/html},
}

@misc{noauthor_emoflonibex_nodate,
	title = {{eMoflon}::{IBeX} {\textbar} {eMoflon} {Project} {Site}},
	url = {https://emoflon.org/ibex/#feature-overview-2},
	urldate = {2025-04-18},
	file = {eMoflon\:\:IBeX | eMoflon Project Site:C\:\\Users\\XPS-15\\Zotero\\storage\\SQT7X3TD\\ibex.html:text/html},
}
